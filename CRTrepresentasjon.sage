

# This file was *autogenerated* from the file CRTrepresentasjon.sage
from sage.all_cmdline import *   # import sage library

def linearCombinations(m, n):
    for k1 in range(0 , m):
        for k2 in range(0 , n):
            yield (k1, k2)

def stepByStep(E, P, Q, order, answer):
    assert order.is_squarefree()
    facorder = list(factor(order))
    remainingOrder = order
    recoveredSize = 1 
    Ms, ys = genCRTconstants(order)
    print(Ms, ys)
    ks = {}
    for l, e in facorder:
        ks[l**e] = -1  #-1 means not yet recovered (no need to initialize this, other than readability)
    print(ks)
    while recoveredSize != order:
        # Simulate some random step, two at a time
        fac1 = choice(factor(remainingOrder))[0 ]
        remainingOrder = remainingOrder//fac1
        if remainingOrder != 1 :
            fac2 = choice(factor(remainingOrder))[0 ]
            remainingOrder = remainingOrder//fac2
        else:
            fac2 = 1 
        print(f"recovering {fac1*fac2}-part")

        recoveredpart = recPart(recoveredSize, ks, Ms, ys)

        for ki, kj in linearCombinations(fac1, fac2):
            kerStep = P + (recoveredpart + ki*Ms[fac1]*ys[fac1] + kj*Ms[fac2]*ys[fac2])*Q
            kerStep = remainingOrder * kerStep
            if isCorrectStep(E, kerStep, answer):
                print("found")
                ks[fac1] = ki
                ks[fac2] = kj
                break

        recoveredSize *= fac1*fac2
    print(ks)
    return P + recPart(recoveredSize, ks, Ms, ys)*Q


def genCRTconstants(order):
    facorder = factor(order)
    Ms = {}
    for (l,e) in facorder:
        for ei in range(1 , e+1 ):
            Ms[l**(e)] = [l**(i) * order//(l**e) for i in range(ei)]
    ys = {}
    for (l,e) in facorder:
        for ei in range(1 , e+1 ):
            ys[l**e] = pow(Ms[l**e][0], -1 , l**e)
    Ms[1 ] = 1 
    ys[1 ] = 1 
    return Ms, ys

def recPart(recoveredSize, ks, Ms, ys):
    facSize = factor(recoveredSize)
    recovered = 0 
    for l, e in facSize:
        for i in range(e):
            try:
                recovered += ks[l**(i + 1)]*Ms[l**(i + 1)][i]*(ys[l**(i + 1)])
            except KeyError:
                for key in ks:
                    if key.quo_rem(l) == 0:
                        recovered += ks[l**e]*Ms[key][i]*(ys[key])
                        

    return recovered

N = 3*3*5*7*13
ks = {9: 1, 5: 1, 7: 4, 13: 8, 3: 0}
Ms, ys = genCRTconstants(N)
print(Ms)
print(ys)
print(recPart(N, ks, Ms, ys) % N)

""" 0 2730 3276 4680 22680, 0 1 1 4 8 """